-- 7장. 테이블 생성, 구조변경, 삭제     - DDL
-- 데이터 입력(INSERT문), 데이터삭제(DELETE), 수정(UPDATE), 검색(SELECT)  -DML

--1.테이블 생성
CREATE TABLE BOOK(
    BOOKID NUMBER(4),
    BOOKNAME VARCHAR2(100),
    PUBLISHER VARCHAR2(20),
    PRICE NUMBER(7),
    PRIMARY KEY(BOOKID) );
CREATE TABLE BOOK(
    BOOKID NUMBER(4) PRIMARY KEY,
    BOOKNAME VARCHAR2(100),
    PUBLISHER VARCHAR2(20),
    PRICE NUMBER(7) );
SELECT * FROM BOOK;
DESC BOOK;
SELECT * FROM EMP;
SELECT ROWNUM, EMPNO, ENAME FROM EMP;   -- 데이터 출력시 논리적인 순서
SELECT ROWNUM, BOOKID, BOOKNAME, PRICE FROM BOOK;
--EMP01 - EMPNO(NUMBER4), ENAME(VARCHAR2(20)), SAL(NUMBER(7,2))
CREATE TABLE EMP01(
    EMPNO NUMBER(4),
    ENAME VARCHAR2(20),
    SAL NUMBER(7,2) );
--DEPT01 - DEPTNO(NUMBER2), DNAME(VARCHAR2(14)), LOC(VARCHAR2(13))
CREATE TABLE DEPT01(
    DEPTNO NUMBER(2),
    DNAME VARCHAR2(14),
    LOC VARCHAR(13) );
SELECT * FROM  DEPT01;
--서브쿼리를 이용한 CREATE TABLE
CREATE TABLE EMP02 
    AS 
    SELECT * FROM EMP; --SELECT수행결과가 EMP02(구조와 데이터만, 제약조건(EX->KEY)은 안들어감.
SELECT * FROM EMP02;
DESC EMP02;
DESC EMP;
--EMP테이블의 사번, 이름, 부서번호 필드만 COPY한 EMP03생성
CREATE TABLE EMP03 AS SELECT EMPNO, ENAME, DEPTNO FROM EMP;
SELECT * FROM EMP03;
DESC EMP03;
--EMP 테이블의 이름, 급여만 COPY한 EMP04테이블 생성
CREATE TABLE EMP04 AS SELECT ENAME, SAL FROM EMP;
SELECT * FROM EMP04;
--EMP 테이블에서 10번 부서 직원의 모든 데이터를 COPY한 EMP05테이블 생성
CREATE TABLE EMP05 AS SELECT * FROM EMP WHERE DEPTNO=10;
SELECT * FROM EMP05;
--EMP테이블 구조만 COPY한 EMP06테이블 생성(데이터는 없는 테이블)
CREATE TABLE EMP06 AS SELECT * FROM EMP WHERE EMPNO=NULL;
CREATE TABLE EMP06 AS SELECT * FROM EMP WHERE 1=0;
SELECT * FROM EMP06;
DESC EMP06;
--DEPT 테이블 구조만 COPY한 DEPT02테이블 생성(데이터 없는 테이블)
CREATE TABLE DEPT02 AS SELECT * FROM DEPT WHERE 1=0;
SELECT * FROM DEPT02;
DESC DEPT02;
SELECT * FROM TAB;

-- 테이블 구조 바꾸기 ALTER TABLE
--- 새로운 필드 추가 ALTER TABLE 테이블이름 ADD(필드이름 타입,...);
DESC EMP03;
ALTER TABLE EMP03 ADD(JOB VARCHAR2(10),SAL NUMBER(7,2));
ALTER TABLE EMP03 ADD(MGR NUMBER(4));
SELECT * FROM EMP03;
--- 현재 필드의 타입 수정 ALTER TABLE 테이블이름 MODIFY(수정하고자 하는 필드 타입);
ALTER TABLE EMP03 MODIFY(EMPNO VARCHAR2(5)); --불가(EMPNO필드에 이미 NUMBER데이터 존재)
ALTER TABLE EMP03 MODIFY(JOB VARCHAR2(20));
ALTER TABLE EMP03 MODIFY(ENAME VARCHAR2(5)); --불가. 이미 6자리 문자 데이터가 존재
ALTER TABLE EMP03 MODIFY(ENAME VARCHAR2(30));
--- 필드 삭제 ALTER TABLE 테이블 DROP COLUMN 필드명
-- 물리적인 삭제보다는 논리적인 삭제한후 접근하지 않는 시간에 물리적인 삭제가 일반적.
ALTER TABLE EMP03 DROP COLUMN JOB;
SELECT * FROM EMP03;
ALTER TABLE EMP03 DROP COLUMN DEPTNO;
-- 논리적으로 필드 삭제(특정 필드 접근 불가로 변경)
ALTER TABLE EMP03 SET UNUSED(SAL); 
SELECT * FROM EMP03;
ALTER TABLE EMP03 DROP UNUSED COLUMNS; --논리적으로 접근 불가한 필드들 물리적삭제

-- 테이블삭제 DROP TABLE 테이블이름;
DROP TABLE EMP01;
DESC EMP01;
-- 테이블의 모든 데이터를 제거하는 명령(DDL; 취소불가)
SELECT * FROM EMP02;
TRUNCATE TABLE EMP02;
SELECT * FROM EMP02;
--테이블 이름을 변경
RENAME EMP02 TO EMP2;
-- DDL명령어 수행하면 데이터 사전(시스템테이블)을 알아서 오라클이 수정함.
-- 사용자는 데이터 딕셔너리를 수정X, 검색X. 데이터딕셔너리뷰 를 통해서만 볼수 있음.
-- 데이터 딕셔너리뷰의 종류 DBA_XXX,ALL_XXX,USER_XXX
-- DATADICTIONARY 에 있는것들
SELECT * FROM USER_TABLES;
SELECT * FROM USER_INDEXES;
SELECT * FROM USER_CONSTRAINTS;
SELECT * FROM USER_VIEWS;   

SELECT * FROM DBA_TABLES;
SELECT * FROM DBA_INDEXES;
SELECT * FROM DBA_CONSTRAINTS;
SELECT * FROM DBA_VIEWS;

SELECT * FROM ALL_TABLES;
SELECT * FROM ALL_INDEXES;
SELECT * FROM ALL_CONSTRAINTS;
SELECT * FROM ALL_VIEWS;

SHOW USER;
-- DML(데이터추가, 데이터삭제, 데이터수정, 데이터검색)
-- 데이터추가 INSERT INTO 테이블명 (필드명1, 필드명2,...) VALUES (값1, 값2,...);
SELECT * FROM DEPT01;
INSERT INTO DEPT01(DEPTNO, DNAME, LOC) VALUES (10, 'ACCOUNT', '종로');
DESC DEPT01;
--PRIMARY KEY는 중복된값이나 NULL값은 불가
INSERT INTO DEPT(DNAME, LOC, DEPTNO) VALUES('IT', '종로', NULL);
--DEPT01 20,'IT',NULL
INSERT INTO DEPT01(DEPTNO, DNAME, LOC) VALUES(20,'IT', NULL);
SELECT DEPTNO, DNAME, NVL(LOC, '사무실못얻음') FROM DEPT01;
--DEPT01 30,'영업',NULL
INSERT INTO DEPT01(DEPTNO, DNAME) VALUES(30, '영업');
SELECT * FROM DEPT01;
INSERT INTO DEPT01 VALUES(40, '기획', '용산'); --VALUES앞 생략할경우-> 순서맞춰야 하고 빈데이터는 무조건 NULL입력
SELECT * FROM DEPT02;
--DEPT내용을(10~30) DEPT02에 추가
INSERT INTO DEPT02 SELECT * FROM DEPT WHERE DEPTNO<40;

CREATE TABLE SAM01(
    EMPNO NUMBER(4),
    ENAME VARCHAR2(10),
    JOB VARCHAR2(9),
    SAL NUMBER(7,2)
    PRIMARY KEY(EMPNO));
DESC SAM01;
SELECT * FROM SAM01;
INSERT INTO SAM01 VALUES(1000, 'APPLE', 'POLICE',10000);
INSERT INTO SAM01 VALUES(1010, 'BANANA', 'NURSE',15000);
INSERT INTO SAM01 VALUES(1020, 'ORANGE', 'DOCTOR',25000);
INSERT INTO SAM01 VALUES(1030, 'VERY', NULL ,25000);
INSERT INTO SAM01 VALUES(1040, 'CAT', NULL ,2000);
INSERT INTO SAM01 SELECT EMPNO, ENAME, JOB, SAL FROM EMP WHERE DEPTNO=10;
SELECT * FROM SAM01;

--데이터 수정하기
-- UPDATE 테이블이름 SET 필드명1=값1, 필드명2=값2 WHERE 조건;
-- 조건을 넣지 않으면 모든 데이터가 수정되므로 주의.
CREATE TABLE EMP01 AS SELECT * FROM EMP;
SELECT * FROM EMP01;
UPDATE EMP01 SET DEPTNO=30;
--모든 직원의 SAL을 10%인상시키는 UPDATE
UPDATE EMP01 SET SAL=SAL*1.1;
--모든 직원의 입사일을 지금으로 바꾸는 UPDATE 중요
UPDATE EMP01 SET HIREDATE=SYSDATE;
SELECT * FROM EMP01;
--급여가 3000이상인 사원만 급여를 10%인상하는 UPDATE
UPDATE EMP01 SET SAL=SAL*1.1 WHERE SAL>=3000;
DROP TABLE EMP01;
CREATE TABLE EMP01 AS SELECT * FROM EMP;
--근무지가 'DALLAS'인 사원들만 SAL을 1000인상
UPDATE EMP01 SET SAL=SAL+1000 WHERE DEPTNO =(SELECT DEPTNO FROM DEPT WHERE LOC='DALLAS');  
--SCOTT사원의 부서번호를 20으로, 직급은 MANAGER로 수정
UPDATE EMP01 SET DEPTNO=20, JOB='MANAGER' WHERE ENAME='SCOTT';
SELECT * FROM EMP01 WHERE ENAME='SCOTT';
--SMITH의 입사일자를 오늘로, SAL은 5000으로 COMM은 400으로 수정
UPDATE EMP01 SET HIREDATE=SYSDATE, SAL=5000, COMM=400 WHERE ENAME='SMITH';
SELECT * FROM EMP01 WHERE ENAME='SMITH';
--20번 부서의 지역명을 40번 부서의 지역명으로 변경하기
SELECT * FROM DEPT01;
UPDATE DEPT01 SET LOC = (SELECT LOC FROM DEPT01 WHERE DEPTNO=40) WHERE DEPTNO=20;
-- 30번 부서의 지역명, 부서명을 40번 부서의 지역명, 부서명으로 수정
UPDATE DEPT01 SET (LOC, DNAME) = (SELECT LOC, DNAME FROM DEPT01 WHERE DEPTNO=40) WHERE DEPTNO=30;
-- 모든 사원의 급여와 입사일을 KING과 같은 값으로 수정하는 UPDATE
UPDATE EMP01 SET (SAL, HIREDATE) = (SELECT SAL, HIREDATE FROM EMP01 WHERE ENAME='KING');
SELECT * FROM EMP01;

--3. 데이터 삭제 DELETE FROM 테이블 WHERE 조건;
SELECT * FROM DEPT01;
DELETE FROM DEPT01; --DML인 DELETE은 ROLLBACK 가능
TRUNCATE TABLE DEPT01; -- DDL은 ROLLBACK 불가
ROLLBACK;
--EMP01테이블에서 30번부서 직원 삭제
DELETE FROM EMP01 WHERE DEPTNO=30;
SELECT * FROM EMP01;
--SAM01 테이블에서 JOB이 지정되어있지 않은 행 삭제
DELETE FROM SAM01 WHERE JOB IS NULL;
SELECT * FROM SAM01;
--EMP01 테이블에서 부서명이 'SALES'부서인 직원들 삭제
INSERT INTO EMP01 SELECT * FROM EMP WHERE DEPTNO = (SELECT DEPTNO FROM DEPT WHERE DNAME='SALES');
DELETE FROM EMP01 WHERE DEPTNO = (SELECT DEPTNO FROM DEPT WHERE DNAME='SALES');

--제약조건
SELECT * FROM EMP;
SELECT * FROM DEPT;
INSERT INTO EMP(EMPNO, ENAME, DEPTNO)  VALUES(9999, '홍', 50); 

--제약조건에 따른 테이블 생성
DROP TABLE DEPT1;
CREATE TABLE DEPT1(
    DEPTNO NUMBER(2) PRIMARY KEY,
    DNAME VARCHAR2(14) NOT NULL UNIQUE,
    LOC VARCHAR2(13) NOT NULL);
DESC DEPT1;
DROP TABLE EMP1;
CREATE TABLE EMP1( 
    EMPNO NUMBER(4),
    ENAME VARCHAR2(10),
    JOB VARCHAR2(9) NOT NULL,               --NOT NULL 제약조건
    MGR NUMBER(4),
    HIREDATE DATE DEFAULT SYSDATE,          --제약조건은 아님
    SAL NUMBER(7,2) CHECK (SAL>=0),         --CHECK제약 조건
    COMM NUMBER(7,2),
    DEPTNO NUMBER(2), --외래키(FOREIGN KEY) 제약조건
    PRIMARY KEY(EMPNO),  --PRIMARY KEY 데약조건
    UNIQUE(ENAME),      --UNIQUE  제약조건
    FOREIGN KEY(DEPTNO) REFERENCES DEPT1(DEPTNO));
DESC EMP1;

INSERT INTO DEPT1 VALUES(10, '회계', '종로');
INSERT INTO DEPT1 VALUES(20, '설계', '용산');
UPDATE DEPT1 SET DNAME='회계' WHERE DEPTNO=20; --제약조건 위반으로 실행 불가
INSERT INTO DEPT1 VALUES(30, '전산', '중구');
SELECT * FROM DEPT1;

INSERT INTO EMP1 VALUES (1000, 'SMITH', 'MANAGER', 2000, '81/01/01', 800, NULL, 10);
INSERT INTO EMP1(EMPNO, ENAME, JOB, SAL, DEPTNO) VALUES(2000, 'SCOTT', 'SALESMAN', 2000, 30);
SELECT * FROM EMP1;
INSERT INTO EMP1(EMPNO, ENAME, JOB, HIREDATE, SAL, DEPTNO) VALUES
            (3000, 'WARD', 'SALESMAN',NULL, 3000, 20);
SELECT TO_CHAR(HIREDATE,'YYYY') FROM EMP1 WHERE EMPNO=2000;
DROP TABLE EMP1;
DROP TABLE DEPT1;
COMMIT;  --DML 쿼리를 데이터베이스에 적용.